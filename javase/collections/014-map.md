# 1.概述

​		Java中的Map接口是和Collection接口同一等级的集合根接口，它表示一个键值对(key-value)的映射。类似数学中函数的概念。一个Map中，任意一个key都有唯一确定的value与其对应，这个key-value的映射就是map。

​		Map 中元素的顺序取决于迭代器迭代时的顺序，有的实现类保证了元素输入输出时的顺序，比如说TreeMap；有的实现类则是无序的，比如HashMap。其架构图可以描述如下:

![014-1](..\images\014-1.png)

* Map是映射接口，Map中存储的内容是键值对(key-value)。
* AbstractMap是继承于Map的抽象类，它实现了Map中的大部分API。其它Map的实现类可以通过继承AbstractMap来减少重复编码。
* SortedMap是继承于Map的接口。SortedMap中的内容是排序的键值对，排序的方法是通过比较器(Comparator)。
* NavigableMap是继承于SortedMap的接口。相比于SortedMap，NavigableMap有一系列的导航方法；如"获取大于/等于某对象的键值对"、“获取小于/等于某对象的键值对”等等。 
* TreeMap继承于AbstractMap，且实现了NavigableMap接口；因此，TreeMap中的内容是“有序的键值对”！
* HashMap继承于AbstractMap，但没实现NavigableMap接口；因此，HashMap的内容是“键值对，但不保证次序”！
* Hashtable虽然不是继承于AbstractMap，但它继承于Dictionary(Dictionary也是键值对的接口)，而且也实现Map接口；因此，Hashtable的内容也是“键值对，也不保证次序”。但和HashMap相比，Hashtable是线程安全的，而且它支持通过Enumeration去遍历。
* WeakHashMap继承于AbstractMap。它和HashMap的键类型不同，WeakHashMap的键是“弱键”。

​		HashMap 是基于“拉链法”实现的散列表。一般用于单线程程序中。Hashtable 也是基于“拉链法”实现的散列表。它一般用于多线程程序中。WeakHashMap 也是基于“拉链法”实现的散列表，它一般也用于单线程程序中。相比HashMap，WeakHashMap中的键是“弱键”，当“弱键”被GC回收时，它对应的键值对也会被从WeakHashMap中删除；而HashMap中的键是强键。TreeMap 是有序的散列表，它是通过红黑树实现的。它一般用于单线程中存储有序的映射。

# 2.Map

​		Map的定义如下：

```java
public interface Map<K,V> { }
```

* Map是一个键值对(key-value)映射接口。Map映射中不能包含重复的键；每个键最多只能映射到一个值。
* Map接口提供三种collection视图，允许以键集、值集或键-值映射关系集的形式查看某个映射的内容。
* Map映射顺序。有些实现类，可以明确保证其顺序，如TreeMap；另一些映射实现则不保证顺序，如HashMap 类。
* Map的实现类应该提供2个“标准的”构造方法：第一个，void（无参数）构造方法，用于创建空映射；第二个，带有单个Map类型参数的构造方法，用于创建一个与其参数具有相同键-值映射关系的新映射。实际上，后一个构造方法允许用户复制任意映射，生成所需类的一个等价映射。尽管无法强制执行此建议（因为接口不能包含构造方法），但是 JDK中所有通用的映射实现都遵从它。

## 2.1.API

```java
//从此映射中移除所有映射关系
abstract void                 clear()	
//如果此映射包含指定键的映射关系，则返回 true    
abstract boolean              containsKey(Object key)	
//如果此映射将一个或多个键映射到指定值，则返回 true    
abstract boolean              containsValue(Object value)	
//返回此映射中包含的映射关系的Set视图    
abstract Set<Entry<K, V>>     entrySet()		
//比较指定的对象与此映射是否相等    
abstract boolean              equals(Object object)	
//返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null    
abstract V                    get(Object key)
//返回此映射的哈希码值    
abstract int                  hashCode()	
//如果此映射未包含键-值映射关系，则返回 true    
abstract boolean              isEmpty()		
//返回此映射中包含的键的Set视图    
abstract Set<K>               keySet()	
//将指定的值与此映射中的指定键关联    
abstract V                    put(K key, V value)	
//从指定映射中将所有映射关系复制到此映射中    
abstract void                 putAll(Map<? extends K, ? extends V> map)	
//如果存在一个键的映射关系，则将其从此映射中移除    
abstract V                    remove(Object key)
//返回此映射中的键-值映射关系数    
abstract int                  size()	
//返回此映射中包含的值的Collection视图    
abstract Collection<V>        values()			
```

# 3 Map.Entry

​		Map.Entry的定义如下：

```java
interface Entry<K,V> { }
```


​		Map.Entry是Map中内部的一个接口，Map.Entry是键值对，Map通过 entrySet() 获取Map.Entry的键值对集合，从而通过该集合实现对键值对的操作。

3.1.API
abstract boolean     	equals(Object object)	//比较指定对象与此项的相等性
abstract K             	getKey()			//返回与此项对应的键
abstract V             	getValue()			//返回与此项对应的值
abstract int         	hashCode()			//返回此映射项的哈希码值
abstract V             	setValue(V object)	//用指定的值替换与此项对应的值


4.AbstractMap
	AbstractMap的定义如下：
public abstract class AbstractMap<K,V> implements Map<K,V> {}
	AbstractMap类提供Map接口的骨干实现，以最大限度地减少实现此接口所需的工作。
	要实现不可修改的映射，编程人员只需扩展此类并提供entrySet方法的实现即可，该方法将返回映射的映射关系set视图。通常，返回的set将依次在 AbstractSet上实现。此set不支持add()或remove()方法，其迭代器也不支持remove()方法。
	要实现可修改的映射，编程人员必须另外重写此类的put方法（否则将抛出 UnsupportedOperationException），entrySet().iterator() 返回的迭代器也必须另外实现其remove方法。

4.1.成员变量
transient volatile Set<K>        keySet;	//保存map中所有键的Set
transient volatile Collection<V> values;	//保存map中所有值的集合
	都是 transient, volatile, 分别表示不可序列化、并发环境下变量的修改能够保证线程可见性。
	需要注意的是 volatile 只能保证可见性，不能保证原子性，需要保证操作是原子性操作，才能保证使用 volatile 关键字的程序在并发时能够正确执行。
	
4.2.API
abstract Set<Entry<K, V>>     entrySet()
void                 clear()
boolean              containsKey(Object key)
boolean              containsValue(Object value)
boolean              equals(Object object)
V                    get(Object key)
int                  hashCode()
boolean              isEmpty()
Set<K>               keySet()
V                    put(K key, V value)
void                 putAll(Map<? extends K, ? extends V> map)
V                    remove(Object key)
int                  size()
String               toString()
Collection<V>        values()
Object               clone()

4.2.1.添加
	默认是不支持添加操作的，实现类需要重写 put() 方法
4.2.2.删除
public V remove(Object key) {
    //获取保存 Map.Entry 集合的迭代器
    Iterator<Entry<K,V>> i = entrySet().iterator();
    Entry<K,V> correctEntry = null;
    //遍历查找，当某个 Entry 的 key 和 指定 key 一致时结束
    if (key==null) {
        while (correctEntry==null && i.hasNext()) {
            Entry<K,V> e = i.next();
            if (e.getKey()==null)
                correctEntry = e;
        }
    } else {
        while (correctEntry==null && i.hasNext()) {
            Entry<K,V> e = i.next();
            if (key.equals(e.getKey()))
                correctEntry = e;
        }
    }

    //找到了，返回要删除的值
    V oldValue = null;
    if (correctEntry !=null) {
        oldValue = correctEntry.getValue();
        //调用迭代器的 remove 方法
        i.remove();
    }
    return oldValue;
}

//调用 Set.clear() 方法清除
public void clear() {
    entrySet().clear();
}

4.2.3.获取
//时间复杂度为 O(n)
//许多实现类都重写了这个方法
public V get(Object key) {
    //使用Set迭代器进行遍历，根据key查找
    Iterator<Entry<K,V>> i = entrySet().iterator();
    if (key==null) {
        while (i.hasNext()) {
            Entry<K,V> e = i.next();
            if (e.getKey()==null)
                return e.getValue();
        }
    } else {
        while (i.hasNext()) {
            Entry<K,V> e = i.next();
            if (key.equals(e.getKey()))
                return e.getValue();
        }
    }
    return null;
}

4.2.4.查询状态
//是否存在指定的 key
//时间复杂度为 O(n)
//许多实现类都重写了这个方法
public boolean containsKey(Object key) {
    //还是迭代器遍历，查找 key，跟 get() 很像啊
    Iterator<Map.Entry<K,V>> i = entrySet().iterator();
    if (key==null) {
        while (i.hasNext()) {
            Entry<K,V> e = i.next();
            //getKey()
            if (e.getKey()==null)
                return true;
        }
    } else {
        while (i.hasNext()) {
            Entry<K,V> e = i.next();
            if (key.equals(e.getKey()))
                return true;
        }
    }
    return false;
}


//查询是否存在指定的值
public boolean containsValue(Object value) {
    Iterator<Entry<K,V>> i = entrySet().iterator();
    if (value==null) {
        while (i.hasNext()) {
            Entry<K,V> e = i.next();
            //getValue()
            if (e.getValue()==null)
                return true;
        }
    } else {
        while (i.hasNext()) {
            Entry<K,V> e = i.next();
            if (value.equals(e.getValue()))
                return true;
        }
    }
    return false;
}


public int size() {
    //使用 Set.size() 获取元素个数
    return entrySet().size();
}

public boolean isEmpty() {
    return size() == 0;
}


4.2.5.用于比较的 equals(), hashCode()
//内部用来测试 SimpleEntry, SimpleImmutableEntry 是否相等的方法
private static boolean eq(Object o1, Object o2) {
    return o1 == null ? o2 == null : o1.equals(o2);
}

//判断指定的对象是否和当前 Map 一致
//为什么参数不是泛型而是 对象呢
//据说是创建这个方法时还没有泛型 - -
public boolean equals(Object o) {
    //引用指向同一个对象
    if (o == this)
        return true;

    //必须是 Map 的实现类
    if (!(o instanceof Map))
        return false;
    //强转为 Map
    Map<?,?> m = (Map<?,?>) o;
    //元素个数必须一致
    if (m.size() != size())
        return false;
    
    try {
        //还是需要一个个遍历，对比
        Iterator<Entry<K,V>> i = entrySet().iterator();
        while (i.hasNext()) {
            //对比每个 Entry 的 key 和 value
            Entry<K,V> e = i.next();
            K key = e.getKey();
            V value = e.getValue();
            if (value == null) {
                //对比 key, value
                if (!(m.get(key)==null && m.containsKey(key)))
                    return false;
            } else {
                if (!value.equals(m.get(key)))
                    return false;
            }
        }
    } catch (ClassCastException unused) {
        return false;
    } catch (NullPointerException unused) {
        return false;
    }
    
    return true;
}

//整个 map 的 hashCode() 
public int hashCode() {
    int h = 0;
    //是所有 Entry 哈希值的和
    Iterator<Entry<K,V>> i = entrySet().iterator();
    while (i.hasNext())
        h += i.next().hashCode();
    return h;
}

4.3.内部类
4.3.1.SimpleEntry可变的键值对	

4.3.2.SimpleImmutableEntry不可变的键值对

	SimpleEntry 与 SimpleImmutableEntry 唯一的区别就是支持 setValue() 操作

5.SortedMap
	SortedMap的定义如下：
public interface SortedMap<K,V> extends Map<K,V> { }
	SortedMap是一个继承于Map接口的接口。它是一个有序的SortedMap键值映射。
	SortedMap的排序方式有两种：自然排序 或者 用户指定比较器。 插入有序 SortedMap 的所有元素都必须实现 Comparable 接口（或者被指定的比较器所接受）。

另外，所有SortedMap 实现类都应该提供 4 个“标准”构造方法：
(01) void（无参数）构造方法，它创建一个空的有序映射，按照键的自然顺序进行排序。
(02) 带有一个 Comparator 类型参数的构造方法，它创建一个空的有序映射，根据指定的比较器进行排序。
(03) 带有一个 Map 类型参数的构造方法，它创建一个新的有序映射，其键-值映射关系与参数相同，按照键的自然顺序进行排序。
(04) 带有一个 SortedMap 类型参数的构造方法，它创建一个新的有序映射，其键-值映射关系和排序方法与输入的有序映射相同。无法保证强制实施此建议，因为接口不能包含构造方法。

5.1.API
// 继承于Map的API
abstract void                 clear()
abstract boolean              containsKey(Object key)
abstract boolean              containsValue(Object value)
abstract Set<Entry<K, V>>     entrySet()
abstract boolean              equals(Object object)
abstract V                    get(Object key)
abstract int                  hashCode()
abstract boolean              isEmpty()
abstract Set<K>               keySet()
abstract V                    put(K key, V value)
abstract void                 putAll(Map<? extends K, ? extends V> map)
abstract V                    remove(Object key)
abstract int                  size()
abstract Collection<V>        values()
// SortedMap新增的API 
abstract Comparator<? super K>     comparator()	//返回对此映射中的键进行排序的比较器；如果此映射使用键的自然顺序，则返回 null
abstract K                         firstKey()	//返回此映射中当前第一个（最低）键
abstract SortedMap<K, V>           headMap(K endKey)	//返回此映射的部分视图，其键值严格小于 endKey
abstract K                         lastKey()	//返回映射中当前最后一个（最高）键
abstract SortedMap<K, V>           subMap(K startKey, K endKey)	//返回此映射的部分视图，其键值的范围从 startKey（包括）到 endKey（不包括）
abstract SortedMap<K, V>           tailMap(K startKey)	//返回此映射的部分视图，其键大于等于 startKey


6.NavigableMap
	NavigableMap的定义如下：
public interface NavigableMap<K,V> extends SortedMap<K,V> { }
	NavigableMap是继承于SortedMap的接口。它是一个可导航的键-值对集合，具有了为给定搜索目标报告最接近匹配项的导航方法。
	NavigableMap分别提供了获取“键”、“键-值对”、“键集”、“键-值对集”的相关方法。

6.1.API
	
abstract Entry<K, V>             ceilingEntry(K key)
abstract Entry<K, V>             firstEntry()
abstract Entry<K, V>             floorEntry(K key)
abstract Entry<K, V>             higherEntry(K key)
abstract Entry<K, V>             lastEntry()
abstract Entry<K, V>             lowerEntry(K key)
abstract Entry<K, V>             pollFirstEntry()
abstract Entry<K, V>             pollLastEntry()
abstract K                       ceilingKey(K key)
abstract K                       floorKey(K key)
abstract K                       higherKey(K key)
abstract K                       lowerKey(K key)
abstract NavigableSet<K>         descendingKeySet()
abstract NavigableSet<K>         navigableKeySet()
abstract NavigableMap<K, V>      descendingMap()
abstract NavigableMap<K, V>      headMap(K toKey, boolean inclusive)
abstract SortedMap<K, V>         headMap(K toKey)
abstract SortedMap<K, V>         subMap(K fromKey, K toKey)
abstract NavigableMap<K, V>      subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)
abstract SortedMap<K, V>         tailMap(K fromKey)
abstract NavigableMap<K, V>      tailMap(K fromKey, boolean inclusive)

	NavigableMap除了继承SortedMap的特性外，它的提供的功能可以分为4类：
第1类，提供操作键-值对的方法。
               lowerEntry、floorEntry、ceilingEntry 和 higherEntry 方法，它们分别返回与小于、小于等于、大于等于、大于给定键的键关联的 Map.Entry 对象。
               firstEntry、pollFirstEntry、lastEntry 和 pollLastEntry 方法，它们返回和/或移除最小和最大的映射关系（如果存在），否则返回 null。
第2类，提供操作键的方法。这个和第1类比较类似
               lowerKey、floorKey、ceilingKey 和 higherKey 方法，它们分别返回与小于、小于等于、大于等于、大于给定键的键。
第3类，获取键集。
              navigableKeySet、descendingKeySet分别获取正序/反序的键集。
第4类，获取键-值对的子集。

7.Dictionary
	Dictionary的定义如下：
public abstract class Dictionary<K,V> {}
	NavigableMap是JDK 1.0定义的键值对的接口，它也包括了操作键值对的基本函数。

7.1.API

abstract Enumeration<V>     elements()
abstract V                  get(Object key)
abstract boolean            isEmpty()
abstract Enumeration<K>     keys()
abstract V                  put(K key, V value)
abstract V                  remove(Object key)
abstract int                size()


8.遍历
	根据 Map 提供的三种视图，可以有三种 map 遍历方式 :
1.使用keySet遍历：
    Set set = map.keySet();
    for (Object key : set) {
        System.out.println(map.get(key));
    }
2.使用values 遍历：
    Collection values = map.values();
    Iterator iterator = values.iterator();
    while (iterator.hasNext()){
        System.out.println("value " + iterator.next());
    }
3.使用 Entry 遍历
    Set entrySet = map.entrySet();
    for (Object o : entrySet) {
        Map.Entry entry = (Map.Entry) o;
        System.out.println(entry);      //key=value
        System.out.println(entry.getKey() + " / " + entry.getValue());
    }


9.HashMap和Hashtable异同

9.1.HashMap和Hashtable的相同点
	HashMap和Hashtable都是存储“键值对(key-value)”的散列表，而且都是采用拉链法实现的。
	存储的思想都是：通过table数组存储，数组的每一个元素都是一个Entry；而一个Entry就是一个单向链表，Entry链表中的每一个节点就保存了key-value键值对数据。
	添加key-value键值对：首先，根据key值计算出哈希值，再计算出数组索引(即，该key-value在table中的索引)。然后，根据数组索引找到Entry(即，单向链表)，再遍历单向链表，将key和链表中的每一个节点的key进行对比。若key已经存在Entry链表中，则用该value值取代旧的value值；若key不存在Entry链表中，则新建一个key-value节点，并将该节点插入Entry链表的表头位置。
	删除key-value键值对：删除键值对，相比于“添加键值对”来说，简单很多。首先，还是根据key计算出哈希值，再计算出数组索引(即，该key-value在table中的索引)。然后，根据索引找出Entry(即，单向链表)。若节点key-value存在与链表Entry中，则删除链表中的节点即可。

9.2.HashMap和Hashtable的不同点
9.2.1继承和实现方式不同
	HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。
	Hashtable 继承于Dictionary，实现了Map、Cloneable、java.io.Serializable接口。
1.1 HashMap和Hashtable都实现了Map、Cloneable、java.io.Serializable接口。
	实现了Map接口，意味着它们都支持key-value键值对操作。支持“添加key-value键值对”、“获取key”、“获取value”、“获取map大小”、“清空map”等基本的key-value键值对操作。
      实现了Cloneable接口，意味着它能被克隆。
      实现了java.io.Serializable接口，意味着它们支持序列化，能通过序列化去传输。
1.2 HashMap继承于AbstractMap，而Hashtable继承于Dictionary
      Dictionary是一个抽象类，它直接继承于Object类，没有实现任何接口。Dictionary类是JDK 1.0的引入的。虽然Dictionary也支持“添加key-value键值对”、“获取value”、“获取大小”等基本操作，但它的API函数比Map少；而且             Dictionary一般是通过Enumeration(枚举类)去遍历，Map则是通过Iterator(迭代器)去遍历。 然而‘由于Hashtable也实现了Map接口，所以，它即支持Enumeration遍历，也支持Iterator遍历。关于这点，后面还会进一步说明。
      AbstractMap是一个抽象类，它实现了Map接口的绝大部分API函数；为Map的具体实现类提供了极大的便利。它是JDK 1.2新增的类。
9.2.2.线程安全不同
	Hashtable的几乎所有函数都是同步的，即它是线程安全的，支持多线程。
	而HashMap的函数则是非同步的，它不是线程安全的。若要在多线程中使用HashMap，需要我们额外的进行同步处理。 对HashMap的同步处理可以使用Collections类提供的synchronizedMap静态方法，或者直接使用JDK 5.0之后提供的java.util.concurrent包里的ConcurrentHashMap类。
9.2.3.对null值的处理不同
	HashMap的key、value都可以为null。
	Hashtable的key、value都不可以为null。

9.2.4.支持的遍历种类不同
	HashMap只支持Iterator(迭代器)遍历。
	而Hashtable支持Iterator(迭代器)和Enumeration(枚举器)两种方式遍历。
	Enumeration 是JDK 1.0添加的接口，只有hasMoreElements(), nextElement() 两个API接口，不能通过Enumeration()对元素进行修改 。
	而Iterator 是JDK 1.2才添加的接口，支持hasNext(), next(), remove() 三个API接口。HashMap也是JDK 1.2版本才添加的，所以用Iterator取代Enumeration，HashMap只支持Iterator遍历。
9.2.5.通过Iterator迭代器遍历时，遍历的顺序不同
	HashMap是“从前向后”的遍历数组；再对数组具体某一项对应的链表，从表头开始进行遍历。
	Hashtabl是“从后往前”的遍历数组；再对数组具体某一项对应的链表，从表头开始进行遍历。
	HashMap和Hashtable都实现Map接口，所以支持获取它们“key的集合”、“value的集合”、“key-value的集合”，然后通过Iterator对这些集合进行遍历。由于“key的集合”、“value的集合”、“key-value的集合”的遍历原理都是一样的；下面，我以遍历“key-value的集合”来进行说明。
	HashMap 和Hashtable 遍历"key-value集合"的方式是：(01) 通过entrySet()获取“Map.Entry集合”。 (02) 通过iterator()获取“Map.Entry集合”的迭代器，再进行遍历。
	HashMap的实现方式：先“从前向后”的遍历数组；对数组具体某一项对应的链表，则从表头开始往后遍历。
	Hashtable的实现方式：先从“后向往前”的遍历数组；对数组具体某一项对应的链表，则从表头开始往后遍历。
9.2.6.容量的初始值 和 增加方式都不一样
	HashMap默认的容量大小是16；增加容量时，每次将容量变为“原始容量x2”。
	Hashtable默认的容量大小是11；增加容量时，每次将容量变为“原始容量x2 + 1”。
	HashMap默认的“加载因子”是0.75, 默认的容量大小是16。
	当HashMap的 “实际容量” >= “阈值”时，(阈值 = 总的容量 * 加载因子)，就将HashMap的容量翻倍。
	Hashtable默认的“加载因子”是0.75, 默认的容量大小是11。 
	当Hashtable的 “实际容量” >= “阈值”时，(阈值 = 总的容量 x 加载因子)，就将变为“原始容量x2 + 1”。
9.2.7.添加key-value时的hash值算法不同
	HashMap添加元素时，是使用自定义的哈希算法。
	Hashtable没有自定义哈希算法，而直接采用的key的hashCode()。
	HashMap添加元素时，是使用自定义的哈希算法。
	Hashtable没有自定义哈希算法，而直接采用的key的hashCode()。
9.2.8.部分API不同
	Hashtable支持contains(Object value)方法，而且重写了toString()方法；
	而HashMap不支持contains(Object value)方法，没有重写toString()方法。
9.3.HashMap和Hashtable使用的情景
	其实，若了解它们之间的不同之处后，可以很容易的区分根据情况进行取舍。例如：(01) 若在单线程中，我们往往会选择HashMap；而在多线程中，则会选择Hashtable。(02)，若不能插入null元素，则选择Hashtable；否则，可以选择HashMap。
	但这个不是绝对的标准。例如，在多线程中，我们可以自己对HashMap进行同步，也可以选择ConcurrentHashMap。当HashMap和Hashtable都不能满足自己的需求时，还可以考虑新定义一个类，继承或重新实现散列表；当然，一般情况下是不需要的了。

10.HashMap和WeakHashMap异同
10.1.HashMap和WeakHashMap的相同点
	它们都是散列表，存储的是“键值对”映射。
	它们都继承于AbstractMap，并且实现Map基础。
	它们的构造函数都一样。
	它们都包括4个构造函数，而且函数的参数都一样。
	默认的容量大小是16，默认的加载因子是0.75。
	它们的“键”和“值”都允许为null。
	它们都是“非同步的”。
10.2.HashMap和WeakHashMap的不同点
10.2.1.HashMap实现了Cloneable和Serializable接口，而WeakHashMap没有。
	HashMap实现Cloneable，意味着它能通过clone()克隆自己。
	HashMap实现Serializable，意味着它支持序列化，能通过序列化去传输。
10.2.2.HashMap的“键”是“强引用(StrongReference)”，而WeakHashMap的键是“弱引用(WeakReference)”。
	WeakReference的“弱键”能实现WeakReference对“键值对”的动态回收。当“弱键”不再被使用到时，GC会回收它，WeakReference也会将“弱键”对应的键值对删除。
	这个“弱键”实现的动态回收“键值对”的原理呢？其实，通过WeakReference(弱引用)和ReferenceQueue(引用队列)实现的。 首先，我们需要了解WeakHashMap中：
	第一，“键”是WeakReference，即key是弱键。
	第二，ReferenceQueue是一个引用队列，它是和WeakHashMap联合使用的。当弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 WeakHashMap中的ReferenceQueue是queue。
	第三，WeakHashMap是通过数组实现的，我们假设这个数组是table。

10.3.动态回收
10.3.1.新建WeakHashMap，将“键值对”添加到WeakHashMap中。
	将“键值对”添加到WeakHashMap中时，添加的键都是弱键。
	实际上，WeakHashMap是通过数组table保存Entry(键值对)；每一个Entry实际上是一个单向链表，即Entry是键值对链表。
10.3.2.当某“弱键”不再被其它对象引用，并被GC回收时。在GC回收该“弱键”时，这个“弱键”也同时会被添加到queue队列中。
	例如，当我们在将“弱键”key添加到WeakHashMap之后；后来将key设为null。这时，便没有外部外部对象再引用该了key。
	接着，当Java虚拟机的GC回收内存时，会回收key的相关内存；同时，将key添加到queue队列中。
10.3.3.当下一次我们需要操作WeakHashMap时，会先同步table和queue。table中保存了全部的键值对，而queue中保存被GC回收的“弱键”；同步它们，就是删除table中被GC回收的“弱键”对应的键值对。
	例如，当我们“读取WeakHashMap中的元素或获取WeakReference的大小时”，它会先同步table和queue，目的是“删除table中被GC回收的‘弱键’对应的键值对”。删除的方法就是逐个比较“table中元素的‘键’和queue中的‘键’”，若它们相当，则删除“table中的该键值对”。